import sys

from os.path import isdir
from os.path import realpath
from os import makedirs

import datetime

from procsimulator.CommunitySpecificator import CommunitySpecificator
from procsimulator.ConsumptionGenerator import ConsumptionGenerator
from procsimulator.DataFromCSV import DataFromCSV
from procsimulator.DataFromSmile import DataFromSmile
from procsimulator.DataFromTomorrow import DataFromTomorrow
from procsimulator.RenewableEnergyGenerator import RenewableEnergyGenerator
from procsimulator.CommunityGenerator import CommunityGenerator
from procsimulator.CommunityManagerStrategy import CommunityManagerStrategy
from procsimulator.MinimizeCostsPyomo import MinimizeCostsPyomo

from PySide6 import QtCore as qc, QtWidgets as qw, QtGui as qg

class InfoScreen(qw.QWidget):
	def __init__(self, title, text):
		"""
		Screen to show progress of simulation

		Args:
			title: upper text
			text: lower text
		"""
		super().__init__()
		self.setStyleSheet("text-align: center")

		self.title = qw.QLabel(title)
		self.text = qw.QLabel(text)
		self.cancelLab = qw.QLabel("The operation will be cancelled as soon as possible")
		self.cancelLab.hide()
		self.btnCancel = qw.QPushButton("Cancel")
		self.btnCancel.setCheckable(True)
		self.btnCancel.setAutoExclusive(True)
		self.cancelled = False

		self.title.setAlignment(qc.Qt.AlignCenter)
		self.text.setAlignment(qc.Qt.AlignCenter)
		self.cancelLab.setAlignment(qc.Qt.AlignCenter)

		layout = qw.QVBoxLayout()
		layout.setAlignment(qc.Qt.AlignTop)
		layout.addStretch()
		layout.addWidget(self.title)
		layout.addWidget(self.text)
		layout.addWidget(self.cancelLab)
		layout.addStretch()
		layout.addWidget(self.btnCancel)
		self.setLayout(layout)

	def setTitle(self, title):
		"""
		Sets the title

		Args:
			title: text to be shown
		"""
		self.title.setText(title)

	def setText(self, text):
		"""
		Sets the text

		Args:
			text: text to be shown
		"""
		self.text.setText(text)

	def setCancelled(self):
		"""
		Signals the simulation should be cancelled, shows text confirming it will cancel as soon as possible
		"""
		self.cancelLab.setVisible(True)
		self.cancelled = True

	def controlProgress(self, code):
		"""
		Updates the text on the info screen based on signals sent from ProcsimRun

		Args:
			code: code to tell which stage simulation is at
		"""
		text = None
		if code == ProcsimRun.CONSUMPTION:
			text = "Simulating Energy Consumption"
		elif code == ProcsimRun.RENEWABLE_ENERGY:
			text = "Simulating Renewable Energy Generation"
		elif code == ProcsimRun.COMMUNITY:
			text = "Simulating Community"
		elif code == ProcsimRun.OPTIMISATION:
			text = "Optimizing Energy Usage"
		elif code == ProcsimRun.TIMESLOTS:
			text == "Logging timeslot placement"
		else:
			return
		self.setText(text)

class ProcsimRun(qc.QObject):
	def __init__(self, skipCg = False, optimMethod = 0, localPV = "", days = 5,
		path_steps_seconds = "output/test/second", 
		path_steps_minutes = "output/test/minute",
		path_steps_after_first = "output/test/afteroptimization",
		path_steps_after_second = "output/test/aftersecoptimization",
		community_file = "data.json", simulate = False, optimize = False):
		"""
		Class to run PROCSIM
		
		Args:
			skipCg: whether to skip the Consumption Generator step
			optimMethod: optimisation method to use (index from Settings.optimizationNames)
			localPV: path to the CSV containing solar data (leave empty to use API)
			days: number of days to simulate
			path_steps_seconds: path of the consumption profiles generated by ANTGen (at 1 Hz)
			path_steps_minutes: path of the resampled consumption profiles (at 1/60Hz)
			path_steps_after_first: path of the consumption profiles after the 1st step of the optimization
			path_steps_after_second: path of the consumption profiles after the 2nd step of the optimization
			community_file: JSON file containing the community configuration
			simulate: whether to run the simulate function
			optimize: wheter to run the optimize function
		"""
		super().__init__()

		self.cancel = False

		self.runSimulate = simulate
		self.runOptimize = optimize

		self.days = days
		self.skipCg = skipCg
		self.optimMethod = optimMethod
		self.localPV = localPV

		self.communityFile = community_file
		self.path_steps_seconds = path_steps_seconds
		self.path_steps_minutes = path_steps_minutes
		self.path_steps_after_first = path_steps_after_first
		self.path_steps_after_second = path_steps_after_second

	finished = qc.Signal() #signal finished the PROCSIM procedure
	progress = qc.Signal(int) #signal progress in the simulation to show info to the user 
	error = qc.Signal(Exception) #signal exception occurrence
	#progress codes
	CONSUMPTION, \
	RENEWABLE_ENERGY, \
	COMMUNITY, \
	OPTIMISATION, \
	TIMESLOTS = range(5)

	def run(self, tryexcept = True):
		"""
		Run PROCSIM. If no option is specified does a full run
		"""
		procedures = []
		noSelection = not self.runSimulate and not self.runOptimize 
		if self.runSimulate or noSelection:
			procedures.append(self.simulate)
		if self.runOptimize or noSelection:
			procedures.append(self.optimize)
		if tryexcept:
			try:
				for p in procedures:
					p()
				self.finished.emit()
			except Exception as ex:
				self.error.emit(ex)
				self.finished.emit()
		else: # this else is for testing
			for p in procedures:
				p()
			self.finished.emit()

	def simulate(self):
		"""
		Simulates the community's consumption.
		Using PROCSIM's Consumption Generator, Renewable Energy Generator and Community Generator modules.
		"""
		#Creating directories if needed
		if not isdir(self.path_steps_seconds+"/output"):
			makedirs(realpath(self.path_steps_seconds)+"/output")
		if not isdir(self.path_steps_minutes):
			makedirs(realpath(self.path_steps_minutes))
			
		print("SIMULATING")
		cg = ConsumptionGenerator(self.communityFile, self.path_steps_seconds, self.path_steps_minutes)
		pv_dat = self.getPV()
		wind_dat = self.getWind()
		reg = RenewableEnergyGenerator(cg, pv_dat, wind_dat, cg.path_steps_minutes)
		cmg = CommunityGenerator(cg.path_steps_minutes)

		if not self.skipCg:
			self.progress.emit(ProcsimRun.CONSUMPTION)
			if self.cancel:
				return
			self.cgExecute(cg, str(self.days), "houses")
			self.createTimeslotsFilesSim(cg.get_timeslots(cg.get_community(), True), len(cg.get_community())) #using True because it's how it's used in the CommunityManager module

		self.progress.emit(ProcsimRun.RENEWABLE_ENERGY)
		if self.cancel:
			return
		reg.execute(str(self.days))
		self.progress.emit(ProcsimRun.COMMUNITY)
		if self.cancel:
			return
		cmg.execute()

	def optimize(self):
		"""
		Optimises the community's consumption.
		Uses PROCSIM's Community Manager module (and subclasses).
		"""
		#creating directories if needed
		if not isdir(self.path_steps_after_first):
			makedirs(realpath(self.path_steps_after_first))
		if not isdir(self.path_steps_after_second):
			makedirs(realpath(self.path_steps_after_second))

		print("OPTIMISING")
		self.progress.emit(ProcsimRun.OPTIMISATION)
		cg = ConsumptionGenerator(self.communityFile, self.path_steps_seconds, self.path_steps_minutes)
		cm = self.getCommunityManager(self.optimMethod, cg, self.path_steps_minutes, self.path_steps_after_first, self.path_steps_after_second)
		if self.cancel:
			return
		self.cmExecute(cm, cg)

	def cgExecute(self, cg, days, config_files_path, just_a_day = False, database_files = False):
		"""
		Consumption Generator execute function without showing any graphs and added checks for cancellation
		
		Args:
			cg: Consumption Generator object in use
      		days: number of the days to generate data (profiles)
      		config_files_path: path/folder where there are the house configuration files (.conf)
      		just_a_day: if true, only 1 day is considered, otherwise all the days are considered
      		database_files: if true, converts the database files, otherwise convertes the community files (false should be used)
		"""
		community = cg.get_community()

		cg.create_users_files(community)
		if self.cancel:
			return
		cg.create_houses_files(community)
		if self.cancel:
			return

		cg.contracted_power = cg.calculate_contracted_power(community)
		if self.cancel:
			return

		cg.create_consumption_profiles(community, days, config_files_path)
		if self.cancel:
			return
		cg.convert_data_to_steps_of_one_minute(community, just_a_day, database_files)
		if self.cancel:
			return
		cg.calculate_community_energy_consumption(community)
		if self.cancel:
			return
		cg.calculate_community_baseload_consumption(community)
		if self.cancel:
			return
		cg.calculate_community_not_baseload_consumption()
		if self.cancel:
			return
		cg.calculate_energy(cg.contracted_power)
		if self.cancel:
			return

	def cmExecute(self, cm, cg):
		"""
		Chooses how to execute the Community Manager based on the optimisation method in use
		
		Args:
			cm: Community Manager object in use
		"""
		print(f"USING METHOD {self.optimMethod}")

		if self.optimMethod == 0:
			cm.execute(save_to_file = True)
			self.createTimeslotsFilesOpt(cm.placed_timeslots_array, len(cg.get_community()))
			self.createTimeslotsFilesOpt(cm.second_placed_timeslots_array, len(cg.get_community()), True)
		elif self.optimMethod == 1:
			cm.execute(save_to_file = True)
			self.createTimeslotsFilesOpt(cm.placed_timeslots_array, len(cg.get_community()))
		else:
			print(f"Optimisation method {self.optimMethod} not found, defaulting")
			cm.execute()

	def getCommunityManager(self, optim_method, cg, path_steps_minutes, path_steps_after_first, path_steps_after_second):
		"""
		Get the Community Manager based on the optimisation method in use

		Args:
			optim_method: optimisation method
			cg: Consumption Generator object in use
			path_steps_minutes: path of the resampled consumption profiles (at 1/60Hz)
			path_steps_after_first: path of the consumption profiles after the 1st step of the optimization
			path_steps_after_second: path of the consumption profiles after the 2nd step of the optimization

		Returns:
			appropriate Community Manager
		"""
		if optim_method == 1:
			return MinimizeCostsPyomo(cg, path_steps_minutes, path_steps_after_first, path_steps_after_second)
		else:
			return CommunityManagerStrategy(cg, path_steps_minutes, path_steps_after_first, path_steps_after_second)

	def getPV(self):
		"""
		Gets solar data from CSV or Smile based on specified local data path

		Returns:
			appropriate solar data 
		"""
		if self.localPV:
			print(f"USING LOCAL SOLAR FILE: {self.localPV}")
			return DataFromCSV(self.localPV)
		else:
			print("USING SOLAR FILE FROM SMILE")
			return DataFromSmile("https://ems.prsma.com/solcast/public/Fazendinha_solcast-radiation-historical_30min.csv")

	def getWind(self):
		"""
		Gets wind data from Tomorrow (to be improved if more wind data sources are added)

		Returns:
			appropriate wind data
		"""
		return DataFromTomorrow("https://api.tomorrow.io/v4/timelines?location=-73.98529171943665,40.75872069597532&fields=pressureSurfaceLevel,pressureSeaLevel,precipitationIntensity,precipitationType,windSpeed,windGust,windDirection,temperature,temperatureApparent,cloudCover,cloudBase,cloudCeiling,weatherCode&teps=1h&units=metric&apikey=Yckmp3vREbJqyprWGGiTOC1pVaAYO0ZT")

	def createTimeslotsFilesSim(self, tims, noHouses):
		"""
		Creates the timeslots file from the data gathered in the simulation

		Args:
			tims: timeslots dictionary from the ConsumptionGenerator
			noHouses: number of houses in the community
		"""
		self.progress.emit(ProcsimRun.TIMESLOTS)
		timsForFile = [{} for i in range(noHouses)]
		firstDay = None
		for tim in tims:
			house = tim["House"]
			appliance = tim["Appliance"]
			start = tim["Start"][-8:-3] #HH:MM from the timestamp (in string format)
			end = tim["End"][-8:-3] #HH:MM from the timestamp (in string format)
			day = datetime.datetime.strptime(tim["Start"][:10], "%Y-%m-%d").date() #yyyy-mm-dd from the timestamp
			
			if firstDay is None:
				firstDay = day
			elif day < firstDay:
				firstDay = day

			if timsForFile[house].get(appliance) is None:
				timsForFile[house][appliance] = []
			
			timsForFile[house][appliance].append([start, end, day])

		#using firstDay to turn the dates in the dictionary into int, i.e., date == firstDay => 1, date == firstDay+1day => 2, etc.
		for house in timsForFile:
			for appliance in house:
				for times in house[appliance]:
					times[2] = (times[2] - firstDay).days + 1

		self.createTimeslotsFiles(timsForFile, self.path_steps_minutes)

	def createTimeslotsFilesOpt(self, tims, noHouses, secondOptim = False):
		"""
		Creates the timeslots file from the data gathered in the optimisation

		Args:
			tims: placed_timeslots_array from the CommunityManager
			noHouses: number of houses in the community
			secondOptim: if these are the timeslots of a second optimisation
		"""
		self.progress.emit(ProcsimRun.TIMESLOTS)
		timsForFile = [{} for i in range(noHouses)]
		firstDay = None
		for tim in tims: #tim is string "HouseNo*Appliance*TimeslotNo*Start*End"
			tim = tim.split("*")
			house = int(tim[0])
			appliance = tim[1]
			start = tim[3][-8:-3] #HH:MM from the timestamp (in string format)
			end = tim[4][-8:-3] #HH:MM from the timestamp (in string format)
			day = datetime.datetime.strptime(tim[3][:10], "%Y-%m-%d").date() #yyyy-mm-dd from the timestamp
			
			if firstDay is None:
				firstDay = day
			elif day < firstDay:
				firstDay = day

			if timsForFile[house].get(appliance) is None:
				timsForFile[house][appliance] = []
			
			timsForFile[house][appliance].append([start, end, day])

		#using firstDay to turn the dates in the dictionary into int, i.e., date == firstDay => 1, date == firstDay+1day => 2, etc.
		for house in timsForFile:
			for appliance in house:
				for times in house[appliance]:
					times[2] = (times[2] - firstDay).days + 1

		outPath = self.path_steps_after_second if secondOptim else self.path_steps_after_first
		self.createTimeslotsFiles(timsForFile, outPath)

	def createTimeslotsFiles(self, tims, folder):
		"""
		Creates the timeslots file from a formatted dictionary

		Args:
			tims: dictionary in format {"appliance_name": [[start, end, day], ...], ...}
			folder: folder containing the house folders into which the timeslots files will be created
		"""
		for houseNo, house in enumerate(tims):
			path = f"{folder}/house{houseNo}/timeslots"
			with open(path, "w") as f:
				for appliance in sorted(list(house.keys())):
					f.write(appliance)
					for times in house[appliance]:
						f.write(f"({times[0]}-{times[1]},{times[2]})")
					f.write("\n")


if __name__ == '__main__':
	file = "/home/fgbg/Documentos/estagio_iti/procsim/Fazendinha_solcast-radiation-historical_30min.csv"
	runner = ProcsimRun(simulate = True, optimize = False, \
		skipCg = True, optimMethod = 0, localPV = file, days = 2)
	runner.run(tryexcept = False)